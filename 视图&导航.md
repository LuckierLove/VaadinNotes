# 添加视图 
## 创建视图
使用 @Route 注解可以实现
@Route 注解 value 属性代表视图视图名 (类似于 URL 路径)
举个例子，下方代码表示的是 `http://BASE_URL/` 所能请求到的视图

```Java
@Route("")
public class HelloWorld extends Div{
	public HelloWorld() {
		setText("Hello World");
	}
}
```
**注意：永远不要以 `/` 作为路径开头**
## 视图命名
当 @Route 注解作用于一个类上时，并且未指定视图名，默认将以类名的小写形式来命名，并且末尾带有 `View` 将会默认去除，以及根视图 `MainView` 将会变成 `""`。
举几个例子：
- `HelloWorld` 将会变成 `helloWorld`
- `ListView` 将会变成 `list`
- `MainView` 将会变成 `""`
## 视图别名
使用 @RouteAlias 注解，并设置其 value 属性，可为视图创建别名
如下例子
```Java
@Route("")  
@RouteAlias("index")  
@RouteAlias("home")  
public class HomeView extends Div {  
}
```
该视图可以通过以下 URL 访问：
- `http://BASE_URL/`
- `http://BASE_URL/index`
- `http://BASE_URL/home`
## 视图页面标题
默认情况下，视图是没有设置页面标题的，可以通过 `声明式页面标题` 和 `动态页面标题` 来设置
### 声明式页面标题
使用 `@PageTitle` 注解可以直接设置视图页面标题
例子如下
```Java
@Route("")  
@PageTitle("主页")  
public class HomeView extends Div {  
}
```
### 动态页面标题
实现视图动态页面标题需要实现 `HasDynamicTtile` 接口
实现 `getPageTile` 方法，在该方法中运行动态页面标题的生成逻辑，并返回标题。
以下例子将动态设置视图页面标题为当前时间
```Java
@Route("")  
public class HomeView extends Div implements HasDynamicTitle {  
    @Override  
    public String getPageTitle() {  
        return LocalDateTime.now().format(DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss"));  
    }  
}
```
**注意 @PageTitle 和接口 HasDynamicTitle 不可同时出现**

## 导航栏菜单项
大多数 Web 应用都会有一个导航栏，Vaadin 可以使用 `MenuConfiguration` 来生成
一个菜单。当你想把一个视图添加到该菜单可以使用 `@Menu` 注解
以下代码展示了一个标题为 `主页`，图标为 `vaadin:academy-cap` 的菜单项
```Java
@Route("")  
@Menu(title = "主页", order = 1, icon = "vaadin:academy-cap")  
public class HomeView extends Div {  
}
```
`@Route` 注解的属性：
- `title` 表示该菜单项的标题
- `order` 用于菜单项的排序
- `icon`  表示该菜单项的图标，可在 [icon](https://vaadin.com/docs/latest/components/icons/default-icons) 查询
## 包命名风格
官方推荐的视图所在包命名风格是 `[功能].ui.view`
如果视图只由一个类所组成，可以将该类直接放在 `view` 包下。
若视图由多个类所组成，应在 `view` 包下创建一个包，并用该视图名命名，并将组成该视图的类放在该包下。

如果并不知道你新创建的视图是大还是小，那么就先放在 `view` 包下，之后可以重构它。
# 导航到视图
Vaadin 当中有 `RouterLink` 和 `UI.navigate()` 两种方法来导航到视图
## RouterLink
`RouterLink` 就像是 `HTML` 当中的 `<a>` 标签
```Java
var link = new RouterLink("Home", HomeView.class);
mainLayout.add(link);
```
上述示例代码创建了一个展示名称为 `Home` 的  `RouterLink `， 并且其能够导航到视图 ` HomeView `
**注意：Vaadin 要求为 JDK 17 版本以上，意味着可以使用关键字 `var` 进行类型推导**

如果目标视图能够接受一个参数，那么你可以把这个参数传给 `RouterLink` 的构造器
举个例子，`UserInfoView` 实现了 `HasUrlParamter<T>` 接口接收一个 `String` 类型的参数作为用户 ID 
```Java
var link = new RouterLink("User Info", UserInfoView.class, "user123");
mainLayout.add(link);
```

## 编程式导航
即使用 `UI.navigate()` 导航到视图。

下面例子创建了一个按钮，并且监听点击事件，当被点击时跳转到 `HomeView`

```Java
var button = new Button("Index");
button.addClickListener(event -> 
	UI.getCurrent().navigate(HomeView.class)
);
```
如果目标视图也接收一个参数那么可以直接传给 `navigate` 方法
例子如下：
```Java
var button = new Button("Get User Info");
button.addClickListener(event -> 
	UI.getCurrent().navigate(UserInfoView.class, "user1234")
);
```

## 封装自己的API
为了避免项目到处充斥着散乱的 `UI.navigate()` 你可以在相应的 `View` 当中封装一个调用 `UI.navigate()` 的方法。

下面例子，在 `UserInfoView` 当中创建了一个 `showUserInfo` 的静态方法用来导航到该视图，避免直接调用 `UI.navigate()`
```Java
@Route("user-info")  
public class UserInfoView extends Main implements HasUrlParameter<String> {  
  
    public static void showUserInfo(String userId) {  
        UI.getCurrent().navigate(UserInfoView.class, userId);  
    }  
	...
}
```
当你想导航到 `UserInfoView` 视图 只需要如下
```Java
var button = new Button("User Info");
button.addClickListener(event -> 
	UserInfoView.showUserInfo("user1234");
);
```
你甚至还可以封装一个返回 `RouterLink` 类型的静态方法来优化你的代码
```Java
public static RouterLink createShowAllUsersInfoLink(){  
    return new RouterLink("Show All Users Info", UserInfoView.class); 
}
```
# 传递数据到视图
Vaadin 传递参数通过 `URL` 参数
## URL 参数类型
- Route 参数，URL 的一部分，一般用来区分视图
- Query 参数，key-value 对，一般用于 `View` 状态存储
## Route 参数
`Route参数` 是 URL 的一部分动态内容，可以传递额外的信息给 `视图`
举个例子，如果一个程序有一个路径 `hello` 且接收一个参数，那么可以用以下 URL 访问该路径：
- `/hello/world`
- `/hello/vaadin`
- `/hello/java`
其中，`"world"`, `"vaadin"`, `"java"` 都是 `Route参数` 且传递给了，`hello` 路径
### Route 参数和静态路径
静态路径优先于动态路径，举个例子，假设一个程序有 `user` 路径（接收一个 `String` 类型的参数）和 `user/list` 路径
- `/user/user1234` -> 访问 `user` 路径，并且传入参数 `user1234`
- `/user/detail` -> 访问 `user` 路径，并且传入参数 `datail`
- `/user/list` -> 访问路径 `user/list`
- `/user` -> 将会出现 `404 Not Found` 错误
### 访问 Route 参数的值
传递一个 `Route 参数` 给视图需要实现 `HasUrlParameter<T>` 接口，其中的泛型 `T` 是参数的类型，该接口定义了一个 `setParameter` 方法，用于接收传递过来的参数。

举个例子，创建一个 `UserInfoView` 视图接收一个 `userId` 作为参数
```Java
@Route("user-info")  
public class UserInfoView extends Main implements HasUrlParameter<String> {  
    private String userId;  
  
    @Override  
    public void setParameter(BeforeEvent event, String userId) {  
        this.userId = userId; 
    }  
}
```
可以通过访问 `/user-info/user1234`，将会调用 `setParameter` 方法，并将 `user1234` 作为参数传入

### 可选参数
默认情况下，`Route 参数` 是必须的，就比如上面的例子，如果访问 `/user-info` 将会出现 `404 Not Found` 错误。

通过注解 `@OptionalParameter` 可以使的 `Route 参数` 变为可选
```Java
@Route("user-info")  
public class UserInfoView extends Main implements HasUrlParameter<String> {  
    @Override  
    public void setParameter(BeforeEvent event, @OptionalParameter String parameter) {  
        if(parameter == null){  
            showAllUsersInfo();  
        }else{  
            showUserInfo(parameter);  
        }  
    }  
      
    private void showAllUsersInfo(){  
    	...
    }  
      
    private void showUserInfo(String userId){
    	...
    }  
}
```
现在，你可以不带参数访问 `/user-info` 了

### 通配符参数
默认情况下，一个 `Route 参数` 只能捕获 URL 的一部分作为参数，举个例子，如果 `user-info` 路径期望一个 `String` 类型的参数，那么访问 `/user-info/user1234/edit` 将产生 `404 Not Found` 错误。

为了能够捕获 URL 多个部分作为一个参数，应该使用 `@WildcardParamter` 注解

```Java
@Route("user-info")  
public class UserInfoView extends Main implements HasUrlParameter<String> {  
    @Override  
    public void setParameter(BeforeEvent event, @WildcardParameter String parameter) {  
        if(parameter == null){  
            showAllUsersInfo();  
        }else{
        	...
        }
    }  
  
    private void showAllUsersInfo(){  
      ...
    }  
}
```
现在，访问 `/user-info/user1234/edit` 将会把 `user1234/edit` 作为参数传入
**注意：一个空值通配符参数是空字符串 `""`，然而空值可选参数是 `null`，
所以当你访问 `/user-info` 上述例子中，参数为 `""` 而不是 `null`**

## Route Templates
想要接收多个 `Route 参数` 那么就需要使用 `Route templates` 
### 声明多个Route参数
通过使用 `Route template` 来替代用 `@Route` 创建的静态路径以此做到接收多个 `Route 参数`
`Route template` 当中的 `Route 参数` 必须遵守以下形式
`:参数名[修饰符][(正则表达式)]`

下方例子创建了一个接收 `userId` 和 `operation` 两个 ` Route 参数 ` 的 ` View `
```Java
@Route("user-info/:userId/:operation")  
public class UserInfoView extends Main{  
}
```
如果访问 `/user-info/user1234/edit`，路由将会把
`user1234` 作为 `userId`，`edit` 作为 `operation` 传递给 `UserInfoView`

### 访问多个 Route 参数的值

^f88153

通过实现接口 `BeforeEnterObserver` 来访问传递给 `View` 的多个 `Route 参数`，
该接口定义了一个 `beforeEnter` 方法，通过该方法来访问传递过来的 `Route 参数` 们的值
```Java
@Route("user-info/:userId/:operation")  
public class UserInfoView extends Main implements BeforeEnterObserver{  
    private static final String PARAM_USER_ID_NAME = "userId";  
    private static final String PARAM_OPERATION_NAME = "operation";  
  
    @Override  
    public void beforeEnter(BeforeEnterEvent event) {  
        var userId = event.getRouteParameters().get(PARAM_USER_ID_NAME).get();  
        var action = event.getRouteParameters().get(PARAM_OPERATION_NAME).get();  
    }  
}
```
上述代码当中，定义了两个参数名常量 `PARAM_USER_ID_NAME` 和 `PARAM_OPERATION_NAME` 用于从 `RouteParamters` 中获取对应的 `Route 参数`
**注意：`RouteParameters` 的 `get` 方法返回的是一个 `Optional<T>` 类型**
在实际开发当中建议像上述代码当中在靠近注解 `@Route` 的地方定义好参数名常量

### 可选的多个Route 参数
默认情况下，所有 `Route 参数` 都是必须的，正如上面的代码当中，`userId` 和 `operation` 是必须的，若直接访问 `/user-info` 或 `/user-info/user1234` 均会出现 `404 Not Found` 错误。要实现可选 `Route 参数` 则需要使用 `?` 修饰符。
```Java
@Route("user-info/:userId/:operation?")  
public class UserInfoView extends Main implements BeforeEnterObserver{  
    private static final String PARAM_USER_ID_NAME = "userId";  
    private static final String PARAM_OPERATION_NAME = "operation";  
  
    @Override  
    public void beforeEnter(BeforeEnterEvent event) {  
        var userId = event.getRouteParameters().get(PARAM_USER_ID_NAME).get();  
        var action = event.getRouteParameters().get(PARAM_OPERATION_NAME).orElse("default operation");  
    }  
}
```
上述代码在 `Route template` 当中用 `?` 修饰符将 ` operation ` 参数声明为可选。
现在，直接访问 `/user-info/user1234` 并不会产生 `404 Not Found` 错误。

当使用多个可选 `Route 参数` 时，传递过来的值会被从左到右依次赋给每一个参数，
假设 `Route Template` 如下 `/user-info/:userId?/:opeartion?`：
- `/user-info` -> 将会不传递任何参数
- `/user-info/user1234` -> 将会把 `user1234` 作为 `userId` 传递
- `/user-info/user1234/edit` -> 将会把 `user1234` 作为 `userId` 和 `edit` 作为 `operation` 传递

### 通配符多个 Route 参数
默认情况下，一个 `Route 参数` 只能捕获一部分 URL ，但是在 `Route Template` 最后一个 `Route 参数` 可以用修饰符 `*` 将其声明为通配符参数，捕获 URL 剩下的所有的部分。

```Java
@Route("search/:context*")  
public class SearchView extends Main implements BeforeEnterObserver {  
    private final String PARAM_CONTEXT_NAME = "context";  
  
    @Override  
    public void beforeEnter(BeforeEnterEvent event) {  
        var context = event.getRouteParameters().get(PARAM_CONTEXT_NAME).get();  
    }  
}
```
现在当你以不同的 URL 访问 `search` 这个路径参数传 `context` 的内容如下：
- `/search/stackoverflow` -> `context` 参数的值将变为 `stackoverflow`
- `/search/stackoveflow/questions` -> `context` 参数的值将变为 `stackoveflow/questions` 
有时候，需要将 `context` 参数的值用 `/` 分割出来，可以参考下方代码使用 `getWildcard` 方法进行分割
```Java
@Route("search/:context*")  
public class SearchView extends Main implements BeforeEnterObserver {  
    private final String PARAM_CONTEXT_NAME = "context";  
  
    @Override  
    public void beforeEnter(BeforeEnterEvent event) {  
        var context = event.getRouteParameters().getWildcard(PARAM_CONTEXT_NAME);  
          
    }  
}
```
当访问 `/search/stackoverflow/questions/vaadin` 时，`getWildcard` 方法将会返回一个 `List` ，其内容为 `["stackoverflow", "questions", "vaadin"]`。
### 利用正则表达式限制 Route 参数的值
下列代码使用正则表达式将参数 `operation` 参数的值限定成只能为 `update` 或 `delete` 或 `select`
```Java
@Route("user-info/:userId/:operation(update|delete|select)")  
public class SearchView extends Main implements BeforeEnterObserver {  
    private static final String PARAM_USER_ID_NAME = "userId";  
    private static final String PARAM_OPERATION_NAME = "operation";  
  
    @Override  
    public void beforeEnter(BeforeEnterEvent event) {  
        var userId = event.getRouteParameters().get(PARAM_USER_ID_NAME).get();  
        var operation = event.getRouteParameters().get(PARAM_OPERATION_NAME).get();  
    }  
}
```

## Query 参数
`Query 参数` 以 key-value 键值对的形式存在于 URL 的 `? ` 之后，多个 ` Query 参数 ` 以 `&` 分割。
例如 URL：`/users?order=desc&sex=male`
则其中包含的 `Query 参数` 为：
- `order` -> `desc`
- `sex` -> `male` 
`Query 参数` 一般用于存储 `View` 的状态

### 访问 Query 参数的值
访问 `Query 参数` 的值与[[#^f88153|访问多个 Route]] 类似，必须实现接口 `BeforeEnterObserver`，在方法 `beforeEnter` 当中实现访问 `Query 参数`
```Java
@Route  
public class UsersView extends Main implements BeforeEnterObserver {  
    private final String PARAM_ORDER_NAME = "order";  
    private final String PARAM_SEX_NAME = "sex";  
  
    @Override  
    public void beforeEnter(BeforeEnterEvent event) {  
        event.getLocation().getQueryParameters().getSingleParameter(PARAM_ORDER_NAME).  
                ifPresent(order -> {  
                    ...              
                });  
        event.getLocation().getQueryParameters().getSingleParameter(PARAM_SEX_NAME)  
                .ifPresent(sex -> {  
                    ...  
                });  
    }  
}
```
现在，如果访问 `/users?order=desc&sex=male`，`Query 参数` 将为：
- `order` -> `desc`
- `sex` -> `male`
`QueryParameters` 提供了访问 `Query 参数` 的方法，同时也可以使用
`UI.getCurrent().getActiveViewLocation().getQueryParameters()` 
来获取 `QueryParameters`

### 设置 Query 参数
`QueryParameters` 是不可以修改的，意味着不能修改已经存在的 `Query 参数`。
但是，你可以创建一个新的 `QueryParameters` 对象，并把它传给 `UI.navigate()`。
当访问新视图的时候 `Query 参数` 也会被一并设置好。

在接下来的例子当中，`UsersView` 封装了一个 `showUserInfo` 方法，同时接收一个可以为 `null` 的参数 `order`，在 `order` 不为 `null` 的情况下创建一个新的 `QueryParameters` 对象并将，`order` 放进去，再传给 `UI.navigate()`。
```Java
@Route("users")  
public class UsersView extends Main implements BeforeEnterObserver {  
    private static final String PARAM_ORDER_NAME = "order";  
    private static final String PARAM_SEX_NAME = "sex";  
  
    public static void showUsersInfo(String order){  
        var queryParameters = order == null ? QueryParameters.empty() :  
                QueryParameters.of(PARAM_ORDER_NAME, order);  
        UI.getCurrent().navigate(UsersView.class, queryParameters);  
    }
```

### 动态更新 Query 参数
当访问相同的视图时，已存在的视图实例将会被复用。但当浏览器 URL 变化时，`beforeEnter` 方法将会被重新调用。
```Java
@Route("users")  
public class UsersView extends Main implements BeforeEnterObserver {  
    private static final String PARAM_ORDER_NAME = "order";  
    private static final String PARAM_SEX_NAME = "sex";  
  
    public UsersView() {  
        var orderField = new TextField();  
        add(orderField);  
  
        orderField.addValueChangeListener(e ->  
        {  
          var queryParameters = UI.getCurrent().getActiveViewLocation().getQueryParameters()  
                  .merging(PARAM_ORDER_NAME, e.getValue());  
          UI.getCurrent().navigate(UsersView.class, queryParameters);  
        });  
    }
```
上述例子当中，创建了一个文本框，当改变该文本框的内容时，该内容会做为新的 `Query 参数` 并且更新 URL。
注意： 
`QueryParameters` 的 `merging` 方法将会把传入的新键值对添加到当前 `QueryParameters` 对象，并返回该对象，若 `Key` 已经存在则会直接更新对应的 `Value`。
该 Lambda 表达式中的参数  `e` 是 `ComponentValueChangeEvent` 实例，其 `getValue` 方法获取到的是即将更新的新值。

# 添加一个布局
大多数 Web 应用都有一个导航栏，用来在不同视图之间切换。

## 路由布局
在 Vaadin 当中路由布局是实现 `RouterLayout` 接口的 UI 组件，该接口提供两个关键方法（有默认实现）：
- `showRouterLayoutContent` ——在路由布局当中展示给定的视图
- `removeRouterLayoutContent` ——在路由布局当中删除给定视图
当你访问一个视图，路由首先会决定那个布局该使用（如果存在的话），如果你在两个属于相同路由布局的视图之间跳转，那么该路由布局实例将会被复用，如果在属于不同路由布局之间的视图进行跳转，那么跳转时一个新的路由布局实例将被创建，并且会将目标视图传递给该目标视图的 `showRouterLayoutContent` 方法。

## 自动布局
使用注解 `@Layout` 能使布局应用到所有视图，除非视图显示声明不使用 `自动布局`。

```Java
@Layout
public class MainLayout extends AppLayout{
}
```
上述例子，`MainLayout` 布局将自动应用于所有视图。

### 拒绝权（不使用自动布局）
一般情况下 Web 应用是不会暴露其登录视图或是注册视图，这种时候就需要显示声明禁用 `自动布局` 了。
将视图的 `@Route` 注解的属性 `autoLayout` 的值设置为 `false` 来禁用 `自动布局 `。
```Java
@Route(value = "register", autoLayout =false)
public class RegisterView extends Main{
}
```
同样的 `@RouteAlias` 注解也有 `autoLayout` 属性。

### 路径限定
可以通过设置 `@Layout` 的 `value` 属性来限定只有以特定路径开头时才会使用自动布局。
```Java
@Layout("/user")
public class UserLayout extends AppLayout{
}
```
上述例子，`UserLayout` 这个布局将会只应用于路径以 `/user` 开头的视图。
当一个视图的路径能够匹配多个自动布局，那么只会使用最匹配的自动布局。
举个例子，`Main` 布局的路径限定为 `/`（默认），`User` 布局路径限定 `/user`：
- `/` -> 匹配 `Main` 布局
- `/guest` -> 匹配 `Main` 布局
- `/user/wang` -> 匹配 `Main` 布局
- `/user/zhang` -> 匹配 `Main` 布局
**注意：如果两个布局的路径限定完全一样程序会抛出异常**

## 指定布局
可以通过设置 `@Route` 的 `layout` 属性显示的指定视图的布局，
一旦显示指定布局，则会禁用自动布局自动应用到该视图。
```Java
@Route(layout = MainLayout.class)
public class DemoView extends Main{
}
```
`@RouteAlias` 注解同样有 `layout` 属性。

## 嵌套布局
自动布局并不会应用到其他布局上面。
要使得一个布局嵌套在另一个布局里则需要使用 `@ParentLayout` 注解来设置父布局。
```Java
@ParentLayout(MainLayout.class)
public class NestedLayout extends Div implements RouterLayout{
}
```
## 路径前缀
默认情况下，布局是不会影响所应用到的视图的路径。但是通过注解 `@RoutePrefix` 来改变。
```Java
@Route(value = "user-info", layout = AdminLayout.class)
public class UserInfoView extends Main{
}

@RoutePrefix("admin")
public class AdminLayout extends Div implements RouterLayout{
}
```
### 拒绝权（不使用路径前缀）
同样的，视图也可以选择不适用布局所要求的 `路径前缀`。
将视图的 `@Route` 注解的 `absolute` 属性设置为 `true` 来不使用布局的路径前缀
~~就像再说我的路径绝对是这个~~

```Java
@Route(value = "login", layout = UserLayout.class, absolute = true)
public class LoginView extends Main{}

@RoutePrefix("user")
public class UserLayout extends Div implements RouterLayout{}
```
`@RouteAlias` 注解同样有 `absolute` 属性
同样的，嵌套布局也拥有拒绝不适用 `路径前缀` 的权利。
```Java
@RoutePrefix("admin")  
public class AdminLayout extends Div implements RouterLayout {  
}

@ParentLayout(AdminLayout.class)  
@RoutePrefix(value = "nested", absolute = true)  
public class NestedLayout extends Div implements RouterLayout {  
}

@Route(value = "user-info", layout = NestedLayout.class)  
public class UserInfoView extends Main {
}
```
在上面这个例子当中，可以通过 `/nested/user-info` 访问到 `UserInfoView` 视图，而不是 `/admin/nested/user-info`。
